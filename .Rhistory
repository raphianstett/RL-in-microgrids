aic_CNI_selfrelabs <- append(aic_CNI_selfrelabs ,AIC(mptCNI))
aic_PD_selfrelabs <- append(aic_PD_selfrelabs ,AIC(mptPD))
}
aic_CNI_selfrelabs
sample(MDreplication[MDreplication$selfrel == "absent", ]
sample(MDreplication[MDreplication$selfrel == "absent", ],
48, replace = TRUE)
sample(MDreplication[MDreplication$selfrel == "absent", ],
48, replace = TRUE)
dat_absent <- MDreplication[MDreplication$selfrel == "absent", ]
dat_absent
sample(c(1:length(dat_absent$selfrel)), 48)
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48),]
dat_relabs <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
dat_relabs
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-absent extrahieren
dat_absent_agg <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_absent_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_absent_agg[, -1]))
# AIC bestimmen
aic_CNI_selfrelabs <- append(aic_CNI_selfrelabs ,AIC(mptCNI))
aic_PD_selfrelabs <- append(aic_PD_selfrelabs ,AIC(mptPD))
}
aic_CNI_selfrelabs
aic_CNI_selfrelabs <- c()
aic_PD_selfrelabs <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-absent extrahieren
dat_absent_agg <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_absent_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_absent_agg[, -1]))
# AIC bestimmen
aic_CNI_selfrelabs <- append(aic_CNI_selfrelabs ,AIC(mptCNI))
aic_PD_selfrelabs <- append(aic_PD_selfrelabs ,AIC(mptPD))
}
aic_CNI_selfrelabs
plot(aic_CNI_selfrelabs)
plot(aic_CNI_selfrelabs)
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs)
aic_CNI_selfrelabs <- c()
aic_PD_selfrelabs <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-absent extrahieren
dat_absent_agg <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_absent_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_absent_agg[, -1]))
# AIC bestimmen
aic_CNI_selfrelabs <- append(aic_CNI_selfrelabs ,AIC(mptCNI))
aic_PD_selfrelabs <- append(aic_PD_selfrelabs ,AIC(mptPD))
}
# Streudiagramm erstellen (CNI ~ PD)
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs)
#### Problems 09: Moralisches Urteilen ####
###########################################
# Raphael Anstett, 5455308
library(mpt)
data(moraldilemma)
# a)
# Dataframe mit Antworthaeufigkeiten der Bedingungen erstellen
dat <- as.data.frame(aggregate(y~selfrel, MDreplication, sum))
# zuerst allgemeineres Modell spezifizieren
spec_gen <- mptspec(
incon_inac.yes = C + (1 - C) * (1 - N) * (1 - I),
incon_inac.no = (1 - C) * N + (1 - C) * (1 - N) * I,
incon_ac.yes = C + (1 - C) * (1 - N) * J,
incon_ac.no = (1 - C) * N + (1 - C) * (1 - N) * (1 - J),
con_inac.yes = (1 - C) * (1 - N) * (1 - I),
con_inac.no = C + (1 - C) * N + (1 - C) * (1 - N) * I,
con_ac.yes = (1 - C) * (1 - N) * J,
con_ac.no = C + (1 - C) * N + (1 - C) * (1 - N) * (1 - J)
)
# allgemeines Modell zu PD-Modell umaendern durch Restriktionen
specPD <- update(spec_gen, .restr = list(I = 0, J = 1))
# allgemeines Modell zu proCNI-Modell umaendern durch Restriktionen
specCNI <- update(spec_gen, .restr = list(J = I))
# b)
dat_absent <- MDreplication[MDreplication$selfrel == "absent", ]
aic_CNI_selfrelabs <- c()
aic_PD_selfrelabs <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-absent extrahieren
dat_absent_agg <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_absent_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_absent_agg[, -1]))
# AIC bestimmen
aic_CNI_selfrelabs <- append(aic_CNI_selfrelabs ,AIC(mptCNI))
aic_PD_selfrelabs <- append(aic_PD_selfrelabs ,AIC(mptPD))
}
# Streudiagramm erstellen (CNI ~ PD)
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs)
abline(a+bx, a = 0, b = 1)
?abline()
abline(a+bx, a = NULL, b = 1)
abline(a = NULL, b = 1)
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs)
abline(a = NULL, b = 1)
abline(a = 0, b = 1)
?plot()
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs, main = "self-relevance absent",
xlab = "AIC PD-Modell", ylab = "AIC proCIN-Modell")
abline(a = 0, b = 1)
?abline()
plot(aic_CNI_selfrelabs ~ aic_PD_selfrelabs, main = "self-relevance absent",
xlab = "AIC PD-Modell", ylab = "AIC proCIN-Modell")
abline(a = 0, b = 1, col = "red")
#### Problems 09: Moralisches Urteilen ####
###########################################
# Raphael Anstett, 5455308
library(mpt)
data(moraldilemma)
# a)
# Dataframe mit Antworthaeufigkeiten der Bedingungen erstellen
dat <- as.data.frame(aggregate(y~selfrel, MDreplication, sum))
# zuerst allgemeineres Modell spezifizieren
spec_gen <- mptspec(
incon_inac.yes = C + (1 - C) * (1 - N) * (1 - I),
incon_inac.no = (1 - C) * N + (1 - C) * (1 - N) * I,
incon_ac.yes = C + (1 - C) * (1 - N) * J,
incon_ac.no = (1 - C) * N + (1 - C) * (1 - N) * (1 - J),
con_inac.yes = (1 - C) * (1 - N) * (1 - I),
con_inac.no = C + (1 - C) * N + (1 - C) * (1 - N) * I,
con_ac.yes = (1 - C) * (1 - N) * J,
con_ac.no = C + (1 - C) * N + (1 - C) * (1 - N) * (1 - J)
)
# allgemeines Modell zu PD-Modell umaendern durch Restriktionen
specPD <- update(spec_gen, .restr = list(I = 0, J = 1))
# allgemeines Modell zu proCNI-Modell umaendern durch Restriktionen
specCNI <- update(spec_gen, .restr = list(J = I))
# b)
dat_absent <- MDreplication[MDreplication$selfrel == "absent", ]
aic_CNI_abs <- c()
aic_PD_abs <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-absent extrahieren
dat_absent_agg <- aggregate(y~selfrel,
dat_absent[sample(c(1:length(dat_absent$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_absent_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_absent_agg[, -1]))
# AIC bestimmen
aic_CNI_abs <- append(aic_CNI_abs ,AIC(mptCNI))
aic_PD_abs <- append(aic_PD_abs ,AIC(mptPD))
}
# Streudiagramm erstellen (CNI ~ PD)
plot(aic_CNI_abs ~ aic_PD_abs, main = "self-relevance absent",
xlab = "AIC PD-Modell", ylab = "AIC proCIN-Modell")
abline(a = 0, b = 1, col = "red")
# AIC(CNI) >?< AIC(PD)
aic_abs <- aic_CNI_abs - aic_PD_abs
aic_abs
aic_abs > 0
sum(as.numeric(aic_abs > 0))
sum(as.numeric(aic_abs > 0)) > 100
sum(as.numeric(aic_abs < 0)) > 100
sum(as.numeric(aic_abs < 0))
# Anzahl der Faelle, in denen AIC(CNI) niedriger als AIC(PDI)
sum(as.numeric(aic_abs < 0))
# fuehre gleiches Vorgehen fuer Self-relevance present durch
dat_present <- MDreplication[MDreplication$selfrel == "present", ]
aic_CNI_pres <- c()
aic_PD_pres <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-present extrahieren
dat_present_agg <- aggregate(y~selfrel,
dat_present[sample(c(1:length(dat_present$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_present_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_present_agg[, -1]))
# AIC bestimmen
aic_CNI_pres <- append(aic_CNI_pres ,AIC(mptCNI))
aic_PD_pres <- append(aic_PD_pres ,AIC(mptPD))
}
# Streudiagramm erstellen (CNI ~ PD)
plot(aic_CNI_pres ~ aic_PD_pres, main = "self-relevance present",
xlab = "AIC PD-Modell", ylab = "AIC proCIN-Modell")
abline(a = 0, b = 1, col = "red")
# AIC(CNI) >?< AIC(PD)
# > 0 --> AIC(CNI) > AIC(PD) --> PD besser als CNI
# < 0 --> AIC(CNI) < AIC(PD) --> CNI besser als PD
aic_pres <- aic_CNI_pres - aic_PD_pres
# Anzahl der Faelle, in denen AIC(CNI) niedriger als AIC(PDI)
sum(as.numeric(ic_pres < 0))
# AIC(CNI) hauefiger groesser als AIC(PD)
# PD ist besseres Modell
sum(as.numeric(aic_pres < 0))
aic_abs
mean(aic_abs)
mean(aic_pres)
aic_pres <- aic_CNI_pres - aic_PD_pres
sum(as.numeric(aic_pres < 0))
aic_CNI_pres <- c()
aic_PD_pres <- c()
for(i in 1:200){
# Antworthauefigkeiten fuer Self-relevance-present extrahieren
dat_present_agg <- aggregate(y~selfrel,
dat_present[sample(c(1:length(dat_present$selfrel)), 48,
replace = FALSE),] ,sum)
# Modelle an Daten anpassen
mptCNI <- mpt(specCNI, as.numeric(dat_present_agg[,-1]))
mptPD <- mpt(specPD, as.numeric(dat_present_agg[, -1]))
# AIC bestimmen
aic_CNI_pres <- append(aic_CNI_pres ,AIC(mptCNI))
aic_PD_pres <- append(aic_PD_pres ,AIC(mptPD))
}
# Streudiagramm erstellen (CNI ~ PD)
plot(aic_CNI_pres ~ aic_PD_pres, main = "self-relevance present",
xlab = "AIC PD-Modell", ylab = "AIC proCIN-Modell")
abline(a = 0, b = 1, col = "red")
# AIC(CNI) >?< AIC(PD)
# > 0 --> AIC(CNI) > AIC(PD) --> PD besser als CNI
# < 0 --> AIC(CNI) < AIC(PD) --> CNI besser als PD
aic_pres <- aic_CNI_pres - aic_PD_pres
# Anzahl der Faelle, in denen AIC(CNI) niedriger als AIC(PDI)
sum(as.numeric(aic_pres < 0))
# AIC(CNI) hauefiger groesser als AIC(PD)
# PD ist besseres Modell
library(mpt)
data(cognitivedoping)
data(cognitive doping)
specUQM <- mptspec(
13.yes = p13 * s + (1-p13)* n,
13.no = p13 * (1-s) + p13 * (1-n)
23.yes = p23 * s + (1-p23)* n,
23.no = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(
"13.yes" = p13 * s + (1-p13)* n,
"13.no" = p13 * (1-s) + p13 * (1-n)
"23.yes" = p23 * s + (1-p23)* n,
"23.no" = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(
"13.yes" = p13 * s + (1-p13)* n,
"13.no" = p13 * (1-s) + p13 * (1-n)
"23.yes" = p23 * s + (1-p23)* n,
"23.no" = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n)
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n)
)
library(mpt)
# a) Modell spezifizieren
specUQM <- mptspec(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n)
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(c(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n)
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n)
))
specUQM <- mptspec(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n),
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(
"13.yes" = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n),
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n)
)
specUQM <- mptspec(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n),
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n),
.restr = list(p13 = 125.25/365.25,
p23 = 245.25/365.25,
n = 181.25/365.25)
)
mpt(data)
?mpt()
?data()
?mpt()
data(package = "mpt")
mUQM <- mpt(c(238, 352, 164, 414), start = c(.1,.1))
specUQM <- mptspec(
onethird.yes = p13 * s + (1-p13)* n,
onethird.no = p13 * (1-s) + p13 * (1-n),
twothird.yes = p23 * s + (1-p23)* n,
twothird.no = p23 * (1-s) + p23 * (1-n),
.restr = list(p13 = 125.25/365.25,
p23 = 245.25/365.25,
n = 181.25/365.25)
)
# b)
# an Daten anpassen
m
mUQM <- mpt(data = c(238, 352, 164, 414), start = c(.1,.1))
mUQM <- mpt(specUQM, data = c(238, 352, 164, 414), start = c(.1,.1))
specUQM
mUQM <- mpt(specUQM, start = c(.1,.1))
?mpt()
mUQM <- mpt(specUQM, data = c(), start = c(.1,.1))
mUQM <- mpt(specUQM, data = c(.1,.1), start = c(.1,.1))
mUQM <- mpt(specUQM, ), start = c(.1,.1))
mUQM <- mpt(specUQM, start = c(.1,.1))
specUQM
mUQM <- mpt(specUQM, data = c(238, 352, 164, 414), start = c(.1,.1))
mUQM <- mpt(specUQM, data = 1,start = c(.1,.1))
specUQM
specUQM <- mptspec(
onethird.yes = p13 * s13 + (1-p13)* n,
onethird.no = p13 * (1-s13) + p13 * (1-n),
twothird.yes = p23 * s23 + (1-p23)* n,
twothird.no = p23 * (1-s23) + p23 * (1-n),
.restr = list(p13 = 125.25/365.25,
p23 = 245.25/365.25,
n = 181.25/365.25)
)
mUQM <- mpt(specUQM, data = c(238, 352, 164, 414),start = c(.1,.1))
mUQM
mUQM_restr <- mpt(update(specUQM, .restr =  list(s13 = s23),
data = c(238, 352, 164, 414),start = .1)
mUQM_restr <- mpt(update(specUQM, .restr =  list(s13 = s23),
data = c(238, 352, 164, 414),start = .1)
mUQM_restr <- mpt(specUQM_restr, data = c(238, 352, 164, 414),start = .1)
specUQM_restr <- update(specUQM, .restr =  list(s13 = s23)
mUQM_restr <- mpt(specUQM_restr, data = c(238, 352, 164, 414),start = .1)
specUQM_restr <- update(specUQM, .restr =  list(s13 = s23))
mUQM_restr <- mpt(specUQM_restr, data = c(238, 352, 164, 414),start = .1)
mUQM_restr
mUQM
mUQM_restr
anova(mUQM_restr, mUQM)
specUQM <- mptspec(
onethird.yes = p13 * s13 + (1-p13)* n,
onethird.no = p13 * (1-s13) + (1 -p13) * (1-n),
twothird.yes = p23 * s23 + (1-p23)* n,
twothird.no = p23 * (1-s23) + (1-p23) * (1-n),
.restr = list(p13 = 125.25/365.25,
p23 = 245.25/365.25,
n = 181.25/365.25)
)
# b)
data = c(238, 352, 164, 414)
# an Daten anpassen
mUQM <- mpt(specUQM, data = c(238, 352, 164, 414),start = c(.1,.1))
mUQM
specUQM_restr <- update(specUQM, .restr =  list(s13 = s23))
mUQM_restr <- mpt(specUQM_restr, data = c(238, 352, 164, 414),start = .1)
mUQM_restr
anova(mUQM_restr, mUQM)
vcov(m)
vcov(mUQM)
vcov(mUQM)[1,1]
vcov(mUQM)[1,1] - vcov(UQM)[2,2]
vcov(mUQM)[1,1] - vcov(mUQM)[2,2]
var <- diag(vcov(mUQM))
var
se <- sqrt(var)
se
se[1]-se[²]
se[1]-se[2]
coef(mUQM)
diff <- coef(mUQM)[1] - coef(mUQM)[2]
diff
var <- diag(vcov(mUQM))
se <- sqrt(var[1]-var[2])
se
vcov(mUQM)
se <- sqrt(var[1]-var[2])
se
se <- sqrt(var[1])-sqrt(var[2])
se
se_diff <- 2 * sqrt(var[1])-sqrt(var[2])
se_diff
se_diff <- sqrt(var[1])-sqrt(var[2])
se_diff
se_diff <- 2*(sqrt(var[1])-sqrt(var[2]))
se_diff
sqrt(var[1])
sqrt(var[2])
data = c(238, 352, 164, 414)
sum(data)
sqrt(var[1])-sqrt(var[2])
se_diff <- sqrt(var[1])-sqrt(var[2])/sqrt(1168)
se_diff
se_diff <- (sqrt(var[1])-sqrt(var[2]))/sqrt(1168)
se_diff
se_diff <- (sqrt(var[1])/sqrt(1168))-(sqrt(var[2])/sqrt(1168))
se_diff
se_diff <- (sqrt(var[1])/sqrt(1168))+(sqrt(var[2])/sqrt(1168))
se_diff
se_diff <- sqrt(var[1]/1168)+sqrt(var[2]/1168)
se_diff
sqrt(se_diff)
se_diff <- sqrt((var[1]/1168)+(var[2]/1168))
se_diff
dat[1,2]
dat = c(238, 352, 164, 414)
# an Daten anpassen
mUQM <- mpt(specUQM, data = c(238, 352, 164, 414),start = c(.1,.1))
# Teste Hypothese: s13 = s23
# restringiertes Modell
specUQM_restr <- update(specUQM, .restr =  list(s13 = s23))
mUQM_restr <- mpt(specUQM_restr, data = c(238, 352, 164, 414),start = .1)
# Teste Modelle gegeneinander
anova(mUQM_restr, mUQM)
Analysis of Deviance Table
'
Model 1: mUQM_restr
Model 2: mUQM
Resid. Df Resid. Dev Df Deviance Pr(>Chi)
1         1    0.49415
2         0    0.00000  1  0.49415   0.4821'
# Test ist nicht signifikant, G2(1) = 0.494, p = 0.482
# Interpretation?
# c) Konfidenzintervall für die Differenz der Prävalenzparameter
diff <- coef(mUQM)[1] - coef(mUQM)[2]
var <- diag(vcov(mUQM))
se_diff <- sqrt((var[1]/sum(dat[1,2]))+(var[2]/1168))
dat(1,2)
dat(2)
dat[2]
dat[:2]
dat[1:2])
dat[1:2]
sum(dat[1:2])
se_diff <- sqrt((var[1]/sum(dat[1:2]))+(var[2]/sum(dat[3:4])))
se_diff
var[1]/sum(dat[1:2])
(var[2]/sum(dat[3:4])
(var[2]/sum(dat[3:4]))
(var[1]/sum(dat[1:2]))+(var[2]/sum(dat[3:4]))
var[1]/sum(dat[1:2])
sqrt(var[1]/sum(dat[1:2])+var[2]/sum(dat[3:4]))
var[1]/sum(dat[1:2])+var[2]/sum(dat[3:4])
diag(vcov(mUQM))
sqrt(var)
se_dif <- sum(sqrt(var))
se_dif
se_dif <- sum(sqrt(var))
se_dif
se_dif <- sqrt(sum(var))
se_dif
ci <- diff + c(-1,1)*1.96*se_dif
ci
setwd("~/Studium/Bachelorarbeit/Coding")
dat <- read.csv("household_with_pv.csv", sep = ";")
head(dat)
dat[is.na(dat)]<- 0
# plot mean consumption over one day
consumption <- dat$Consumption
consumption[is.na(consumption)] <- 0
cons <- rep(0, each = 24)
for(i in 1:364){
for(j in 1:24){
print(consumption[i*24 + j])
cons[j] <- cons[j] + consumption[i * 24 + j]
}
}
con_mean <- cons / 365
plot(con_mean)
# plot mean consumption over the year
cons2 <- rep(0, each = 365)
for(i in 1:364){
for(j in 1:24){
cons2[i] <- cons2[i] + consumption[i+j]
}
}
plot(cons2, type = "l")
# plot mean production over year
production <- dat$Production
production[is.na(production)] <- 0
prod <- rep(0, each = 365)
for(i in 1:364){
for(j in 1:24){
prod[i] <- prod[i] + production[i+j]
}
}
plot(prod, type = "l")
# plot mean production of one day
prod2 <- rep(0, each = 24)
for(i in 1:364){
for(j in 1:24){
prod2[j] <- prod2[j] + production[i * 24 + j]
}
}
prod_mean <- prod2 / 365
plot(prod_mean, type = "l")
lines(con_mean)
plot(con_mean)
plot(con_mean, type = "l")
plot(con_mean)
plot(prod_mean, type = "l")
